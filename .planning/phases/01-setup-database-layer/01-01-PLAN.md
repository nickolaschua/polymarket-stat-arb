---
phase: 01-setup-database-layer
plan: 01
type: execute
---

<objective>
Set up development database infrastructure: Docker Compose for TimescaleDB, extended configuration, asyncpg connection pool, and test infrastructure with testcontainers.

Purpose: Establish the foundation that all subsequent database plans build on — a running TimescaleDB instance, configured pool, and test fixtures.
Output: docker-compose.yml, extended config.py, src/db/pool.py, tests/conftest.py with testcontainers fixture.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-setup-database-layer/01-RESEARCH.md

@src/config.py

**Key decisions:**
- TimescaleDB over SQLite (compression, continuous aggregates, hypertables)
- asyncpg directly, no ORM (raw SQL for TimescaleDB features, 3x faster bulk inserts)
- asyncpg pool: min_size=2, max_size=10 for dev; max_inactive_connection_lifetime=300s
- testcontainers-python with `timescale/timescaledb:latest-pg17` image
- Windows requires `asyncio.WindowsSelectorEventLoopPolicy` for asyncpg
- Docker image: `timescale/timescaledb:latest-pg17` with telemetry off

**Codebase patterns:**
- Config singleton via `get_config()` (src/config.py)
- Pydantic BaseModel for all config sections
- YAML config + env vars for secrets
- Async-first throughout (asyncio + httpx)
- Logger per module: `logging.getLogger(__name__)`
- snake_case files, PascalCase classes, absolute imports from `src.`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docker-compose.yml and extend DatabaseConfig</name>
  <files>docker-compose.yml, src/config.py, config.example.yaml</files>
  <action>
Create `docker-compose.yml` at project root with TimescaleDB service:
- Image: `timescale/timescaledb:latest-pg17`
- Port mapping: 5432:5432
- Environment: POSTGRES_USER=polymarket, POSTGRES_PASSWORD=polymarket_dev, POSTGRES_DB=polymarket, TIMESCALEDB_TELEMETRY=off
- Named volume: `timescaledb_data:/var/lib/postgresql/data`
- Healthcheck: `pg_isready -U polymarket` (interval 5s, timeout 5s, retries 5)

Extend `DatabaseConfig` in `src/config.py`:
- Replace SQLite URL default with PostgreSQL DSN: `postgresql://polymarket:polymarket_dev@localhost:5432/polymarket`
- Add fields: `min_pool_size: int = 2`, `max_pool_size: int = 10`, `max_inactive_connection_lifetime: float = 300.0`, `command_timeout: int = 60`

Add `CollectorConfig` to `src/config.py` (stub for Phase 2):
- Fields: `price_interval_sec: int = 60`, `orderbook_interval_sec: int = 300`, `metadata_interval_sec: int = 300`, `trade_buffer_size: int = 1000`, `max_markets: int = 10000`
- Add `collector: CollectorConfig` field to main `Config` class

Update `config.example.yaml` with new database and collector sections.

Do NOT change any existing config fields beyond DatabaseConfig.url default. Do NOT add env var support for database password yet (that's for Phase 5 deployment).
  </action>
  <verify>python -c "from src.config import Config; c = Config(); print(c.database.url, c.database.min_pool_size, c.collector.price_interval_sec)"</verify>
  <done>docker-compose.yml exists with healthcheck. DatabaseConfig has pool settings with PostgreSQL DSN default. CollectorConfig stub exists. config.example.yaml updated.</done>
</task>

<task type="auto">
  <name>Task 2: Create src/db package and asyncpg pool singleton</name>
  <files>src/db/__init__.py, src/db/pool.py</files>
  <action>
Create `src/db/` package with `__init__.py` (empty).

Create `src/db/pool.py` with pool singleton matching existing `get_config()` pattern:
- Module-level `_pool: asyncpg.Pool | None = None`
- `async def get_pool() -> asyncpg.Pool`: Creates pool if None or closed. Reads DSN and pool settings from `get_config().database`. Uses `asyncpg.create_pool()` with dsn, min_size, max_size, max_inactive_connection_lifetime, command_timeout.
- `async def close_pool() -> None`: Closes pool and sets to None. Safe to call when already closed.
- `async def init_pool() -> asyncpg.Pool`: Explicit init (calls get_pool). For use in startup sequences where you want to fail-fast on connection errors.

Use `from src.config import get_config` for config access. Type hint all functions. Add module docstring.

Do NOT use `_pool._closed` (private attribute) — instead use try/except on pool operations or track state with a separate boolean. asyncpg.Pool does not expose a public `closed` property reliably across versions.

Do NOT add connection health checks or retry logic here — keep pool.py simple. Retry is handled by the existing retry decorator at the call site.
  </action>
  <verify>python -c "from src.db.pool import get_pool, close_pool, init_pool; print('imports ok')"</verify>
  <done>src/db/pool.py exports get_pool(), close_pool(), init_pool(). Follows singleton pattern matching get_config().</done>
</task>

<task type="auto">
  <name>Task 3: Create test infrastructure with testcontainers</name>
  <files>tests/__init__.py, tests/conftest.py, tests/db/__init__.py, pyproject.toml, requirements.txt</files>
  <action>
Install new dependencies — add to `requirements.txt`:
- `asyncpg>=0.29.0`
- `testcontainers[postgres]>=4.10.0`
- Keep existing dependencies unchanged.

Create `pyproject.toml` with pytest configuration:
- `[tool.pytest.ini_options]`: asyncio_mode = "auto", testpaths = ["tests"], python_files = "test_*.py", python_classes = "Test*", python_functions = "test_*"
- Set `filterwarnings` to ignore DeprecationWarning from testcontainers if needed.

Create `tests/__init__.py` (empty).
Create `tests/db/__init__.py` (empty).

Create `tests/conftest.py` with:
1. Event loop policy fixture (session-scoped): Set `asyncio.WindowsSelectorEventLoopPolicy()` on Windows (check `sys.platform == "win32"`). This MUST run before any async fixtures.
2. TimescaleDB container fixture (session-scoped): Use `PostgresContainer("timescale/timescaledb:latest-pg17")` with username="test", password="test", dbname="testdb". Use context manager pattern (`with PostgresContainer(...) as container`). Yield container.
3. `db_pool` fixture (function-scoped, async): Create asyncpg pool connected to the test container using `container.get_container_host_ip()` and `int(container.get_exposed_port(5432))`. min_size=1, max_size=3. Enable TimescaleDB extension: `CREATE EXTENSION IF NOT EXISTS timescaledb;`. Yield pool. Close pool in teardown.
4. `clean_db` fixture (function-scoped, async): Takes db_pool, drops all tables except schema_migrations between tests for isolation. Use `DROP TABLE IF EXISTS ... CASCADE` for all known tables.

Do NOT use `scope="session"` for db_pool — function scope ensures test isolation. The container is session-scoped (expensive to start), but pools are cheap.

Do NOT put testcontainers import at top level — guard with try/except so non-integration tests don't fail if Docker isn't running.
  </action>
  <verify>pip install asyncpg "testcontainers[postgres]>=4.10.0" && python -c "import asyncpg; from testcontainers.postgres import PostgresContainer; print('deps ok')"</verify>
  <done>requirements.txt has asyncpg + testcontainers. pyproject.toml configures pytest-asyncio. conftest.py has TimescaleDB container + pool + cleanup fixtures. tests/ directory structure created.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `docker compose config` validates docker-compose.yml without errors
- [ ] `python -c "from src.config import Config; c = Config(); assert 'postgresql' in c.database.url"` passes
- [ ] `python -c "from src.db.pool import get_pool, close_pool"` imports succeed
- [ ] `pip install -r requirements.txt` installs without errors
- [ ] `pytest --collect-only` discovers test infrastructure without import errors
</verification>

<success_criteria>

- docker-compose.yml with TimescaleDB service, healthcheck, and named volume
- DatabaseConfig extended with pool settings and PostgreSQL DSN
- CollectorConfig stub added to Config
- config.example.yaml updated with new sections
- src/db/pool.py with get_pool/close_pool/init_pool singleton
- tests/conftest.py with testcontainers TimescaleDB fixture
- pyproject.toml with pytest-asyncio configuration
- All imports resolve, no errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-setup-database-layer/01-01-SUMMARY.md`
</output>
