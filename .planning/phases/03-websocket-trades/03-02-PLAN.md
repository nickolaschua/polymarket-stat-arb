---
phase: 03-websocket-trades
plan: 02
type: execute
---

<objective>
Build the ResolutionTracker collector that polls Gamma API for closed markets, detects resolutions via infer_winner(), and upserts to the resolutions table.

Purpose: Track market resolutions autonomously so downstream ML training data has correct outcome labels.
Output: Working ResolutionTracker class with respx-mocked tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-websocket-trades/03-RESEARCH.md
@.planning/phases/03-websocket-trades/03-CONTEXT.md

# Prior plan output (must exist before executing this plan):
@.planning/phases/03-websocket-trades/03-01-SUMMARY.md

# Key source files:
@src/collector/resolution_tracker.py
@src/collector/market_metadata.py
@src/db/queries/resolutions.py
@src/db/queries/markets.py
@src/config.py
@tests/collector/conftest.py

# Prior phase context:
@.planning/phases/02-core-collectors/02-01-SUMMARY.md

**Tech stack available:** asyncpg, pydantic, respx, httpx
**Established patterns:**
- Collector class: __init__(pool, client, config), collect_once() -> int, never raises
- respx HTTP mocking for Gamma API tests
- Event -> market flattening from MarketMetadataCollector._extract_markets_from_events()
- Defensive camelCase/snake_case key mapping
- Gamma API pagination: limit+offset params

**Constraining decisions:**
- upsert_resolution(pool, dict) with fields: condition_id, outcome, winner_token_id, resolved_at, payout_price, detection_method
- get_unresolved_markets(pool) returns condition_ids where closed=true AND no resolution
- infer_winner() from 03-01 returns resolution_data dict or None
- Gamma API `?closed=true` returns events with nested markets (same format as active events)
- Market metadata collector only fetches active events, so closed markets may have stale `closed=false` in DB
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ResolutionTracker class</name>
  <files>src/collector/resolution_tracker.py, src/config.py</files>
  <action>
    Extend src/collector/resolution_tracker.py (already has infer_winner from 03-01) with ResolutionTracker class:

    1. Add `resolution_check_interval_sec: int = 300` to CollectorConfig in src/config.py

    2. ResolutionTracker class:
       - __init__(self, pool: asyncpg.Pool, config: CollectorConfig):
         Store pool and config. Create httpx.AsyncClient as self._http.
         Get gamma_host from get_config().polymarket.gamma_host.
       - async def close(self): Close self._http client.
       - async def collect_once(self) -> int:
         a. Acquire gamma_limiter before API calls
         b. Paginate Gamma API: GET {gamma_host}/events?closed=true&limit=100&offset=N
            Stop after 3 pages (300 events) or when page returns fewer than limit — we only need recent closings
         c. Flatten events -> markets (reuse same pattern as MarketMetadataCollector._extract_markets_from_events, but extract full raw_market dicts, not transformed dicts)
         d. Collect all condition_ids from the markets found
         e. Batch-check DB for existing resolutions:
            rows = await pool.fetch("SELECT condition_id FROM resolutions WHERE condition_id = ANY($1::text[])", condition_ids)
            already_resolved = {row["condition_id"] for row in rows}
         f. For each market NOT already resolved, call infer_winner(raw_market)
         g. For each non-None result, call upsert_resolution(pool, result)
         h. Also update markets.closed = true for ALL condition_ids seen in closed events:
            await pool.execute("UPDATE markets SET closed = true, updated_at = NOW() WHERE condition_id = ANY($1::text[]) AND closed = false", all_condition_ids)
            This ensures markets.closed stays in sync even though metadata collector only fetches active events.
         i. Log: "Detected N new resolutions from M closed markets"
         j. Return count of new resolutions upserted.
         k. Wrap entire method in try/except, log errors, return 0. Never raises.

    AVOID: Paginating all closed events (could be thousands). Limit to 3 pages max.
    AVOID: Querying individual resolutions in a loop. Use batch ANY($1::text[]) query.
    AVOID: Modifying MarketMetadataCollector or PolymarketClient — keep resolution tracker self-contained.
  </action>
  <verify>python -c "from src.collector.resolution_tracker import ResolutionTracker; print('import OK')"</verify>
  <done>ResolutionTracker class exists with collect_once(), CollectorConfig has resolution_check_interval_sec</done>
</task>

<task type="auto">
  <name>Task 2: Write respx-mocked tests for ResolutionTracker</name>
  <files>tests/collector/test_resolution_tracker.py</files>
  <action>
    Extend tests/collector/test_resolution_tracker.py (already has infer_winner tests from 03-01) with ResolutionTracker integration tests using respx and migrated_pool.

    Test cases (use @respx.mock decorator, mock Gamma API responses):

    1. test_collect_once_detects_resolution:
       - Mock Gamma API returning one closed event with resolved market (outcomePrices '["1","0"]')
       - Call collect_once() -> returns 1
       - Verify resolution upserted in DB via get_resolution()
       - Verify markets.closed updated to true

    2. test_collect_once_skips_unresolved:
       - Mock Gamma API returning closed event with unresolved market (outcomePrices '["0.95","0.05"]')
       - Call collect_once() -> returns 0
       - Verify no resolution in DB

    3. test_collect_once_skips_already_resolved:
       - Pre-insert a resolution for a condition_id
       - Mock Gamma API returning that same condition_id as closed+resolved
       - Call collect_once() -> returns 0 (doesn't re-upsert)

    4. test_collect_once_paginates:
       - Mock Gamma API: first page returns 100 events, second page returns 50 (stops)
       - Verify both pages processed (use respx side_effect or route matching with offset param)

    5. test_collect_once_api_error_returns_zero:
       - Mock Gamma API returning 500
       - Call collect_once() -> returns 0
       - No exception raised

    6. test_collect_once_updates_market_closed:
       - Pre-insert a market with closed=false
       - Mock Gamma API returning that market as closed (but not resolved)
       - Verify market.closed updated to true in DB

    Use existing fixtures from conftest.py: migrated_pool.
    Create ResolutionTracker with pool, default CollectorConfig.
    Use gamma_host from PolymarketConfig default for respx URL matching.

    Import structure: from src.collector.resolution_tracker import ResolutionTracker, from src.db.queries.resolutions import get_resolution, upsert_resolution.
  </action>
  <verify>pytest tests/collector/test_resolution_tracker.py -v -- all tests pass (both infer_winner from 03-01 and new ResolutionTracker tests)</verify>
  <done>6 new integration tests pass, covering resolution detection, skip logic, pagination, error handling, and market.closed sync</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] pytest tests/collector/test_resolution_tracker.py -v -- all tests pass
- [ ] python -c "from src.collector.resolution_tracker import ResolutionTracker" succeeds
- [ ] No import errors or type issues
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- ResolutionTracker follows collector pattern (collect_once -> int, never raises)
- Resolution detection correctly uses infer_winner from 03-01
- Market closed status synced from Gamma API
- 6+ integration tests with respx mocking
</success_criteria>

<output>
After completion, create `.planning/phases/03-websocket-trades/03-02-SUMMARY.md`:

# Phase 03 Plan 02: Resolution Tracker Collector Summary

**[Substantive one-liner]**

## Accomplishments
## Files Created/Modified
## Decisions Made
## Issues Encountered
## Next Step

Ready for 03-03-PLAN.md (WebSocket Trade Listener Core)
</output>
