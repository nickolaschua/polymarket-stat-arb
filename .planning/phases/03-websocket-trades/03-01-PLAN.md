---
phase: 03-websocket-trades
plan: 01
type: tdd
---

<objective>
Implement and thoroughly test the `infer_winner()` function for detecting resolved markets from Gamma API outcomePrices.

Purpose: Correctness of resolution detection is critical â€” wrong winner labels corrupt all downstream training data. TDD ensures comprehensive edge case coverage before implementation. Per CONTEXT.md: "Better to leave unresolved than record wrong."
Output: Working, tested `infer_winner()` function in `src/collector/resolution_tracker.py`
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-websocket-trades/03-RESEARCH.md
@.planning/phases/03-websocket-trades/03-CONTEXT.md

# Key source files:
@src/db/queries/resolutions.py
@src/db/models.py

# Prior phase context:
@.planning/phases/01-setup-database-layer/01-06-SUMMARY.md
@.planning/phases/02-core-collectors/02-01-SUMMARY.md

**Tech stack available:** asyncpg, pydantic, respx, httpx
**Established patterns:** stringified JSON parsing for Gamma API (outcomePrices, outcomes, clobTokenIds are stringified JSON arrays), defensive camelCase/snake_case key mapping
**Constraining decisions:**
- upsert_resolution() expects dict: (condition_id, outcome, winner_token_id, resolved_at, payout_price, detection_method)
- Gamma API outcomePrices: '["1","0"]' when resolved (winner=1.0, loser=0.0), '["0.52","0.48"]' when unresolved
- CONTEXT.md: "Winner inference must be right. Bad resolution labels corrupt all downstream training data."
</context>

<feature>
  <name>Resolution Winner Inference</name>
  <files>src/collector/resolution_tracker.py, tests/collector/test_resolution_tracker.py</files>
  <behavior>
    infer_winner(raw_market: dict) -> dict | None

    Takes a raw Gamma API market dict with stringified JSON fields.
    Returns a resolution_data dict suitable for upsert_resolution(), or None if not resolved.

    Resolution rule: any element in outcomePrices whose float value == 1.0 indicates the winning outcome.
    The corresponding index in outcomes and clobTokenIds identifies the winner.

    Cases:
    - {"outcomePrices": '["1","0"]', "outcomes": '["Yes","No"]', "clobTokenIds": '["tok_a","tok_b"]', "conditionId": "abc"}
      -> {"condition_id": "abc", "outcome": "Yes", "winner_token_id": "tok_a", "payout_price": 1.0, "detection_method": "gamma_api_polling", "resolved_at": &lt;utc_now&gt;}

    - {"outcomePrices": '["0","1"]', ...} -> second outcome wins

    - {"outcomePrices": '["1.0","0.0"]', ...} -> "1.0" parsed as float 1.0, still detected

    - {"outcomePrices": '["0.52","0.48"]', ...} -> None (not resolved)

    - {"outcomePrices": '["1","0","0"]', "outcomes": '["A","B","C"]', "clobTokenIds": '["t1","t2","t3"]', ...}
      -> {"outcome": "A", "winner_token_id": "t1", ...} (3-outcome market)

    - outcomePrices missing/invalid JSON -> None
    - outcomes or clobTokenIds missing -> still returns result but with None for outcome/winner_token_id
    - Native list types (not stringified) -> handles both str and list inputs
    - "conditionId" (camelCase) and "condition_id" (snake_case) both accepted
    - '["0","0"]' (no winner) -> None
    - Empty arrays -> None

    NEVER raises an exception. Returns None for any parsing failure.
  </behavior>
  <implementation>
    Create src/collector/resolution_tracker.py with:

    1. _parse_json_field(value) -> list helper:
       - If value is already a list, return it
       - If value is a string, json.loads() and return if list, else []
       - On any error (JSONDecodeError, TypeError), return []

    2. infer_winner(raw_market: dict) -> dict | None:
       - Extract condition_id from "conditionId" or "condition_id" (defensive, like market_metadata.py)
       - Parse outcomePrices, outcomes, clobTokenIds via _parse_json_field
       - If outcomePrices is empty, return None
       - Iterate prices: try float(price), if == 1.0 found, that index is the winner
       - Build result dict: condition_id, outcome (from outcomes[idx] if available), winner_token_id (from tokens[idx] if available), payout_price=1.0, detection_method="gamma_api_polling", resolved_at=datetime.now(timezone.utc)
       - If no price == 1.0, return None
       - Wrap entire function body in try/except returning None on any error

    Tests should cover all cases listed in behavior section (12+ test cases).
  </implementation>
</feature>

<verification>
pytest tests/collector/test_resolution_tracker.py -v -- all tests pass
</verification>

<success_criteria>
- Failing tests written and committed (RED)
- Implementation passes all tests (GREEN)
- Refactor if needed (REFACTOR)
- All 2-3 commits present
- infer_winner correctly identifies winners for binary and multi-outcome markets
- infer_winner returns None for unresolved/malformed markets
- infer_winner NEVER raises on any input
</success_criteria>

<output>
After completion, create `.planning/phases/03-websocket-trades/03-01-SUMMARY.md`:

# Phase 03 Plan 01: Resolution Winner Inference Summary

**[Substantive one-liner]**

## TDD Cycle

### RED Phase
- What tests were written and why they fail

### GREEN Phase
- What implementation made tests pass

### REFACTOR Phase
- What cleanup was done (if any)

## Files Created/Modified
## Decisions Made
## Issues Encountered
## Next Step

Ready for 03-02-PLAN.md (Resolution Tracker Collector)
</output>
